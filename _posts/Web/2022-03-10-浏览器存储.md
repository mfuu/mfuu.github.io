---
layout: post
title: 浏览器存储
categories: [Web]
description: 浏览器存储
keywords: Web, 浏览器存储, cookie, localStorage, sessionStorage, indexDB
---


### cookie，localStorage，sessionStorage，indexDB

| 特性 | cookie | localStorage | sessionStorage | indexDB |
| ---- | ------ | ------------ | -------------- | ------- |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K | 5M | 5M | 无限 |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 | 不参与 |

从上表可以看大，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage`。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于 `cookie`，我们还需要注意安全性

| 属性 | 作用 |
| ---- | ---- |
| value | 如果用于保存用户登陆状态，应该将值加密，不能使用明文的用户标识 |
| http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击 |
| secure | 只能在协议为 HTTPS 的请求中携带 |
| same-site | 规定浏览器不能再跨域请求中携带 Cookie，减少 CSRF 攻击 |

### Service Worker

> Service Worker 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。它们还允许访问推送通知和后台同步API

目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能：

```js
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker.register('sw.js')
  .then(function(registration) {
    console.log('service worker 注册成功')
  })
  .catch(function(err) {
    console.log('service worker 注册失败')
  })
}
// sw.js
// 监听 install 事件，回调中缓存所需文件
self.addEventListener('install', e => {
  e.waitUntill(caches.open('my-code').then(function(cache) {
    return cache.addAll(['./index.html', './index.js'])
  }))
})
// 拦截所有请求事件，如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener('fetch', e => {
  e.respondWith(caches.match(e.request).then(function(response) {
    if (response) {
      return response
    }
    console.log('fetch source')
  }))
})
```